/********************************************************************************
 * Copyright (c) 2024 Kopernikus Automotive
 * 
 * This program and the accompanying materials are made available under the
 * terms of the Apache License, Version 2.0 which is available at
 * https://www.apache.org/licenses/LICENSE-2.0.
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 * 
 * SPDX-License-Identifier: Apache-2.0
 ********************************************************************************/
 
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(non_snake_case)]
/* automatically generated by rust-bindgen */

pub const ECAL_ALLOCATE_4ME: u32 = 0;
pub const ECAL_VERSION_MAJOR: u32 = 5;
pub const ECAL_VERSION_MINOR: u32 = 5;
pub const ECAL_VERSION_PATCH: u32 = 5;
pub const ECAL_VERSION: &[u8; 18usize] = b"v5.5.5-3-gb779f09\0";
pub const ECAL_DATE: &[u8; 11usize] = b"07.05.2020\0";
pub const ECAL_PLATFORMTOOLSET: &[u8; 1usize] = b"\0";
pub const eCAL_Init_Publisher: u32 = 1;
pub const eCAL_Init_Subscriber: u32 = 2;
pub const eCAL_Init_Service: u32 = 4;
pub const eCAL_Init_Monitoring: u32 = 8;
pub const eCAL_Init_Logging: u32 = 16;
pub const eCAL_Init_TimeSync: u32 = 32;
pub const eCAL_Init_RPC: u32 = 64;
pub const eCAL_Init_ProcessReg: u32 = 128;
pub const eCAL_Init_All: u32 = 255;
pub const eCAL_Init_Default: u32 = 183;
#[doc = " @brief Common handle for eCAL C API function calls."]
pub type ECAL_HANDLE = *mut ::std::os::raw::c_void;
extern "C" {
    #[doc = " @brief  Get eCAL version string."]
    #[doc = ""]
    #[doc = " @return  Full eCAL version string."]
    pub fn eCAL_GetVersionString() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief  Get eCAL version date."]
    #[doc = ""]
    #[doc = " @return  Full eCAL version date string."]
    pub fn eCAL_GetVersionDateString() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief  Get eCAL version as separated integer values."]
    #[doc = ""]
    #[doc = " @param [out] major_  The eCAL major version number."]
    #[doc = " @param [out] minor_  The eCAL minor version number."]
    #[doc = " @param [out] patch_  The eCAL patch version number."]
    #[doc = ""]
    #[doc = " @return  Zero if succeeded."]
    pub fn eCAL_GetVersion(
        major_: *mut ::std::os::raw::c_int,
        minor_: *mut ::std::os::raw::c_int,
        patch_: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Initialize eCAL API."]
    #[doc = ""]
    #[doc = " @param argc_        Number of command line arguments."]
    #[doc = " @param argv_        Array of command line arguments."]
    #[doc = " @param unit_name_   Defines the name of the eCAL unit."]
    #[doc = " @param components_  Defines which component to initialize."]
    #[doc = ""]
    #[doc = " @return Zero if succeeded, 1 if already initialized, -1 if failed."]
    pub fn eCAL_Initialize(
        argc_: ::std::os::raw::c_int,
        argv_: *mut *mut ::std::os::raw::c_char,
        unit_name_: *const ::std::os::raw::c_char,
        components_: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief  Set/change the unit name of current module."]
    #[doc = ""]
    #[doc = " @param unit_name_  Defines the name of the eCAL unit."]
    #[doc = ""]
    #[doc = " @return  Zero if succeeded."]
    pub fn eCAL_SetUnitName(unit_name_: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Finalize eCAL API."]
    #[doc = ""]
    #[doc = " @param components_  Defines which component to initialize (not yet supported)."]
    #[doc = ""]
    #[doc = " @return Zero if succeeded, 1 if already finalized, -1 if failed."]
    pub fn eCAL_Finalize(components_: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Check eCAL initialize state."]
    #[doc = ""]
    #[doc = " @param component_  Check specific component or 0 for general state of eCAL core."]
    #[doc = ""]
    #[doc = " @return None zero if eCAL is initialized."]
    pub fn eCAL_IsInitialized(component_: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Return the eCAL process state."]
    #[doc = ""]
    #[doc = " @return  None zero if eCAL is in proper state."]
    pub fn eCAL_Ok() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief  Free an eCAL memory block allocated by functions like"]
    #[doc = "         eCAL_Monitoring_GetMonitoring, eCAL_Monitoring_GetLogging,"]
    #[doc = "         eCAL_Sub_Receive ... that use 'ECAL_ALLOCATE_4ME' as"]
    #[doc = "         buffer length parameter and let eCAL allocate"]
    #[doc = "         the memory internally."]
    #[doc = ""]
    #[doc = " @code"]
    #[doc = "            // let eCAL allocate memory for the subscriber buffer and return the pointer to 'buf'"]
    #[doc = "            long long time     = 0;"]
    #[doc = "            int       time_out = 100;   // ms"]
    #[doc = "            void*     buf      = NULL;"]
    #[doc = "            int       buf_len  = eCAL_Sub_Receive(subscriber_handle, &buf, ECAL_ALLOCATE_4ME, &time, timeout);"]
    #[doc = "            if(buf_len > 0)"]
    #[doc = "            {"]
    #[doc = "              ..."]
    #[doc = "              // PROCESS THE BUFFER CONTENT HERE"]
    #[doc = "              ..."]
    #[doc = "              // finally free the allocated memory"]
    #[doc = "              eCAL_FreeMem(buf);"]
    #[doc = "            }"]
    #[doc = " @endcode"]
    pub fn eCAL_FreeMem(mem_: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " @brief Open a named or unnamed event."]
    #[doc = ""]
    #[doc = " @param  event_name_  Event name (\"\" == unnamed)."]
    #[doc = ""]
    #[doc = " @return  Handle to opened event or NULL if failed."]
    pub fn eCAL_Event_gOpenEvent(event_name_: *const ::std::os::raw::c_char) -> ECAL_HANDLE;
}
extern "C" {
    #[doc = " @brief Close an event."]
    #[doc = ""]
    #[doc = " @param handle_  Event handle."]
    #[doc = ""]
    #[doc = " @return  None zero if succeeded."]
    pub fn eCAL_Event_gCloseEvent(handle_: ECAL_HANDLE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set an event active."]
    #[doc = ""]
    #[doc = " @param handle_  Event handle."]
    #[doc = ""]
    #[doc = " @return  None zero if succeeded."]
    pub fn eCAL_Event_gSetEvent(handle_: ECAL_HANDLE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Wait for an event with timeout."]
    #[doc = ""]
    #[doc = " @param handle_   Event handle."]
    #[doc = " @param timeout_  Timeout in ms (-1 == infinite)."]
    #[doc = ""]
    #[doc = " @return  None zero if succeeded."]
    pub fn eCAL_Event_gWaitForEvent(
        handle_: ECAL_HANDLE,
        timeout_: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Check whether an event is valid or not."]
    #[doc = ""]
    #[doc = " @param handle_  Event handle."]
    #[doc = ""]
    #[doc = " @return  None zero if event is valid."]
    pub fn eCAL_Event_gEventIsValid(handle_: ECAL_HANDLE) -> ::std::os::raw::c_int;
}
#[repr(i32)]
#[doc = " @brief Values that represent different log level to filter on monitoring."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum eCAL_Logging_eLogLevel {
    log_level_none = 0,
    log_level_all = 255,
    log_level_info = 1,
    log_level_warning = 2,
    log_level_error = 4,
    log_level_fatal = 8,
    log_level_debug1 = 16,
    log_level_debug2 = 32,
    log_level_debug3 = 64,
    log_level_debug4 = 128,
}
extern "C" {
    #[doc = " @brief Sets the log level."]
    #[doc = ""]
    #[doc = " @param level_  The level."]
    pub fn eCAL_Logging_SetLogLevel(level_: eCAL_Logging_eLogLevel);
}
extern "C" {
    #[doc = " @brief Get the current log level."]
    #[doc = ""]
    #[doc = " @return   The current log level."]
    pub fn eCAL_Logging_GetLogLevel() -> eCAL_Logging_eLogLevel;
}
extern "C" {
    #[doc = " @brief Log a message (with current log level)."]
    #[doc = ""]
    #[doc = " @param msg_  The log message string."]
    pub fn eCAL_Logging_Log(msg_: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " @brief Mark the start of the user core process."]
    pub fn eCAL_Logging_StartCoreTimer();
}
extern "C" {
    #[doc = " @brief Mark the stop of the user core process."]
    pub fn eCAL_Logging_StopCoreTimer();
}
extern "C" {
    #[doc = " @brief Set the current measured core time in s (for user implemented measuring)."]
    #[doc = ""]
    #[doc = " @param time_  The core time."]
    pub fn eCAL_Logging_SetCoreTime(time_: f64);
}
extern "C" {
    #[doc = " @brief Returns the current measured core time in s."]
    pub fn eCAL_Logging_GetCoreTime() -> f64;
}
extern "C" {
    #[doc = " @brief Set topics filter blacklist regular expression."]
    #[doc = ""]
    #[doc = " @param filter_  Topic filter as regular expression."]
    #[doc = ""]
    #[doc = " @return Zero if succeeded."]
    pub fn eCAL_Monitoring_SetExclFilter(
        filter_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set topics filter whitelist regular expression."]
    #[doc = ""]
    #[doc = " @param filter_  Topic filter as regular expression."]
    #[doc = ""]
    #[doc = " @return Zero if succeeded."]
    pub fn eCAL_Monitoring_SetInclFilter(
        filter_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Switch topics filter using regular expression on/off."]
    #[doc = ""]
    #[doc = " @param state_  Filter on / off state."]
    #[doc = ""]
    #[doc = " @return Zero if succeeded."]
    pub fn eCAL_Monitoring_SetFilterState(state_: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get monitoring protobuf string."]
    #[doc = ""]
    #[doc = " @param [out] buf_      Pointer to store the monitoring information."]
    #[doc = " @param       buf_len_  Length of allocated buffer or ECAL_ALLOCATE_4ME if"]
    #[doc = "                        eCAL should allocate the buffer for you (see eCAL_FreeMem)."]
    #[doc = ""]
    #[doc = " @return  Monitoring buffer length or zero if failed."]
    #[doc = " @code"]
    #[doc = "            // let eCAL allocate memory for the monitoring buffer and return the pointer to 'buf'"]
    #[doc = "            void*     buf      = NULL;"]
    #[doc = "            int       buf_len  = eCAL_Monitoring_GetLogging(subscriber_handle, &buf, ECAL_ALLOCATE_4ME);"]
    #[doc = "            if(buf_len > 0)"]
    #[doc = "            {"]
    #[doc = "              ..."]
    #[doc = "              // PROCESS THE BUFFER CONTENT HERE"]
    #[doc = "              ..."]
    #[doc = "              // finally free the allocated memory"]
    #[doc = "              eCAL_FreeMem(buf);"]
    #[doc = "            }"]
    #[doc = " @endcode"]
    pub fn eCAL_Monitoring_GetMonitoring(
        buf_: *mut ::std::os::raw::c_void,
        buf_len_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get logging string."]
    #[doc = ""]
    #[doc = " @param [out] buf_      Pointer to store the logging information."]
    #[doc = " @param       buf_len_  Length of allocated buffer or ECAL_ALLOCATE_4ME if"]
    #[doc = "                        eCAL should allocate the buffer for you (see eCAL_FreeMem)."]
    #[doc = ""]
    #[doc = " @return  Logging buffer length or zero if failed."]
    pub fn eCAL_Monitoring_GetLogging(
        buf_: *mut ::std::os::raw::c_void,
        buf_len_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Publish monitoring protobuf message."]
    #[doc = ""]
    #[doc = " @param state_  Switch publishing on/off."]
    #[doc = " @param name_   Monitoring topic name."]
    #[doc = ""]
    #[doc = " @return Zero if succeeded."]
    pub fn eCAL_Monitoring_PubMonitoring(
        state_: ::std::os::raw::c_int,
        name_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Publish logging protobuf message."]
    #[doc = ""]
    #[doc = " @param state_  Switch publishing on/off."]
    #[doc = " @param name_   Logging topic name."]
    #[doc = ""]
    #[doc = " @return Zero if succeeded."]
    pub fn eCAL_Monitoring_PubLogging(
        state_: ::std::os::raw::c_int,
        name_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[repr(i32)]
#[doc = " @brief  Process start mode (StartProcess)"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum eCAL_Process_eStartMode {
    #[doc = "<  0 == start mode normal"]
    proc_smode_normal = 0,
    #[doc = "<  1 == start mode hidden"]
    proc_smode_hidden = 1,
    #[doc = "<  2 == start mode minimized"]
    proc_smode_minimized = 2,
    #[doc = "<  3 == start mode maximized"]
    proc_smode_maximized = 3,
}
#[repr(i32)]
#[doc = " @brief  Process severity"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum eCAL_Process_eSeverity {
    #[doc = "<  0 == condition unknown"]
    proc_sev_unknown = 0,
    #[doc = "<  1 == process healthy"]
    proc_sev_healthy = 1,
    #[doc = "<  2 == process warning level"]
    proc_sev_warning = 2,
    #[doc = "<  3 == process critical"]
    proc_sev_critical = 3,
    #[doc = "<  4 == process failed"]
    proc_sev_failed = 4,
}
#[repr(i32)]
#[doc = " @brief Process Severity Level"]
#[doc = ""]
#[doc = " enumerations for ECAL_API::SetState functionality"]
#[doc = " where the lowest process severity is generally proc_sev_level1"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum eCAL_Process_eSeverity_Level {
    #[doc = "<  default severity level 1"]
    proc_sev_level1 = 1,
    #[doc = "<  severity level 2"]
    proc_sev_level2 = 2,
    #[doc = "<  severity level 3"]
    proc_sev_level3 = 3,
    #[doc = "<  severity level 4"]
    proc_sev_level4 = 4,
    #[doc = "<  severity level 5"]
    proc_sev_level5 = 5,
}
extern "C" {
    #[doc = " @brief  Dump configuration to console."]
    pub fn eCAL_Process_DumpConfig();
}
extern "C" {
    #[doc = " @brief  Get current host name."]
    #[doc = ""]
    #[doc = " @param [out] name_      Pointer to store the host name."]
    #[doc = " @param       name_len_  Length of allocated buffer or ECAL_ALLOCATE_4ME if"]
    #[doc = "                         eCAL should allocate the buffer for you (see eCAL_FreeMem)."]
    #[doc = ""]
    #[doc = " @return  Buffer length or zero if failed."]
    pub fn eCAL_Process_GetHostName(
        name_: *mut ::std::os::raw::c_void,
        name_len_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief  Get unique host id."]
    #[doc = ""]
    #[doc = " @return  The host id."]
    pub fn eCAL_Process_GetHostID() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief  Get process unit name (defined with eCAL_Initialize)."]
    #[doc = ""]
    #[doc = " @param [out] name_      Pointer to store the unit name."]
    #[doc = " @param       name_len_  Length of allocated buffer or ECAL_ALLOCATE_4ME if"]
    #[doc = "                         eCAL should allocate the buffer for you (see eCAL_FreeMem)."]
    #[doc = ""]
    #[doc = " @return  Buffer length or zero if failed."]
    pub fn eCAL_Process_GetUnitName(
        name_: *mut ::std::os::raw::c_void,
        name_len_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief  Get current process parameter (defined via eCAL_Initialize(argc_, arg_v)."]
    #[doc = ""]
    #[doc = " @param [out] par_      Pointer to store the process parameter."]
    #[doc = " @param       par_len_  Length of allocated buffer or ECAL_ALLOCATE_4ME if"]
    #[doc = "                        eCAL should allocate the buffer for you (see eCAL_FreeMem)."]
    #[doc = " @param       sep_      Separator."]
    #[doc = ""]
    #[doc = " @return  Buffer length or zero if failed."]
    pub fn eCAL_Process_GetTaskParameter(
        par_: *mut ::std::os::raw::c_void,
        par_len_: ::std::os::raw::c_int,
        sep_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief  Sleep current thread."]
    #[doc = ""]
    #[doc = " @param  time_ms_  Time to sleep in ms."]
    pub fn eCAL_Process_SleepMS(time_ms_: ::std::os::raw::c_long);
}
extern "C" {
    #[doc = " @brief  Get current process id."]
    #[doc = ""]
    #[doc = " @return  The process id."]
    pub fn eCAL_Process_GetProcessID() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief  Get current process name."]
    #[doc = ""]
    #[doc = " @param [out] name_      Pointer to store the process name."]
    #[doc = " @param       name_len_  Length of allocated buffer or ECAL_ALLOCATE_4ME if"]
    #[doc = "                         eCAL should allocate the buffer for you (see eCAL_FreeMem)."]
    #[doc = ""]
    #[doc = " @return  Process name length or zero if failed."]
    pub fn eCAL_Process_GetProcessName(
        name_: *mut ::std::os::raw::c_void,
        name_len_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief  Get current process parameter as string."]
    #[doc = ""]
    #[doc = " @param [out] par_      Pointer to store the process parameter."]
    #[doc = " @param       par_len_  Length of allocated buffer or ECAL_ALLOCATE_4ME if"]
    #[doc = "                        eCAL should allocate the buffer for you (see eCAL_FreeMem)."]
    #[doc = ""]
    #[doc = " @return  Process parameter length or zero if failed."]
    pub fn eCAL_Process_GetProcessParameter(
        par_: *mut ::std::os::raw::c_void,
        par_len_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief  Get CPU usage of current process."]
    #[doc = ""]
    #[doc = " @return  The CPU usage in percent."]
    pub fn eCAL_Process_GetProcessCpuUsage() -> f32;
}
extern "C" {
    #[doc = " @brief  Get memory usage of current process."]
    #[doc = ""]
    #[doc = " @return  The memory usage in bytes."]
    pub fn eCAL_Process_GetProcessMemory() -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " @deprecated  Use the function eCAL_Process_GetWClock() instead"]
    pub fn eCAL_Process_GetSClock() -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " @deprecated  Use the function eCAL_Process_GetWBytes() instead"]
    pub fn eCAL_Process_GetSBytes() -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " @brief  Get the write clock of the current process."]
    #[doc = ""]
    #[doc = " @return  The message write count per second."]
    pub fn eCAL_Process_GetWClock() -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " @brief  Get the write bytes of the current process."]
    #[doc = ""]
    #[doc = " @return  The message write bytes per second."]
    pub fn eCAL_Process_GetWBytes() -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " @brief  Get the read clock of the current process."]
    #[doc = ""]
    #[doc = " @return  The message read count per second."]
    pub fn eCAL_Process_GetRClock() -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " @brief  Get the read bytes of the current process."]
    #[doc = ""]
    #[doc = " @return  The message read bytes per second."]
    pub fn eCAL_Process_GetRBytes() -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " @brief  Set process state info."]
    #[doc = ""]
    #[doc = " @param severity_  Severity."]
    #[doc = " @param level_     Severity level."]
    #[doc = " @param info_      Info message."]
    #[doc = ""]
    pub fn eCAL_Process_SetState(
        severity_: eCAL_Process_eSeverity,
        level_: eCAL_Process_eSeverity_Level,
        info_: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief  Start specified process (windows only)."]
    #[doc = ""]
    #[doc = " @param proc_name_       Process name."]
    #[doc = " @param proc_args_       Process argument string."]
    #[doc = " @param working_dir_     Working directory."]
    #[doc = " @param create_console_  Start process in own console window (Windows only)."]
    #[doc = " @param process_mode_    Start normal, hidden, minimized, maximized (Windows only)."]
    #[doc = " @param block_           Block until process finished."]
    #[doc = ""]
    #[doc = " @return  Process id or zero if failed."]
    pub fn eCAL_Process_StartProcess(
        proc_name_: *const ::std::os::raw::c_char,
        proc_args_: *const ::std::os::raw::c_char,
        working_dir_: *const ::std::os::raw::c_char,
        create_console_: ::std::os::raw::c_int,
        process_mode_: eCAL_Process_eStartMode,
        block_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief  Stop specified process (windows only)."]
    #[doc = ""]
    #[doc = " @param proc_name_  Process name."]
    #[doc = ""]
    #[doc = " @return  None zero if successful."]
    pub fn eCAL_Process_StopProcessName(
        proc_name_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief  Stop specified process (windows only)."]
    #[doc = ""]
    #[doc = " @param proc_id_    Process id."]
    #[doc = ""]
    #[doc = " @return  None zero if successful."]
    pub fn eCAL_Process_StopProcessID(proc_id_: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[repr(i32)]
#[doc = " @brief eCAL subscriber event callback struct."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum eCAL_Subscriber_Event {
    sub_event_none = 0,
    sub_event_connected = 1,
    sub_event_disconnected = 2,
    sub_event_dropped = 3,
    sub_event_timeout = 4,
    sub_event_corrupted = 5,
}
#[repr(i32)]
#[doc = " @brief eCAL publisher event callback struct."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum eCAL_Publisher_Event {
    pub_event_none = 0,
    pub_event_connected = 1,
    pub_event_disconnected = 2,
    pub_event_dropped = 3,
}
#[repr(i32)]
#[doc = " @brief eCAL registration event type."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum eCAL_Registration_Event {
    reg_event_none = 0,
    reg_event_publisher = 1,
    reg_event_subscriber = 2,
    reg_event_service = 3,
    reg_event_process = 4,
}
#[doc = " @brief eCAL subscriber receive callback struct (C variant)."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct SReceiveCallbackDataC {
    #[doc = "!< payload buffer"]
    pub buf: *mut ::std::os::raw::c_void,
    #[doc = "!< payload buffer size"]
    pub size: ::std::os::raw::c_long,
    #[doc = "!< source id"]
    pub id: ::std::os::raw::c_longlong,
    #[doc = "!< source time stamp"]
    pub time: ::std::os::raw::c_longlong,
    #[doc = "!< source write clock"]
    pub clock: ::std::os::raw::c_longlong,
}

impl Default for SReceiveCallbackDataC {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " @brief eCAL receive callback function"]
#[doc = ""]
#[doc = " @param topic_name_  Topic name of the data source (publisher)."]
#[doc = " @param data_        Data payload struct."]
#[doc = " @param par_         Forwarded user defined parameter."]
pub type ReceiveCallbackCT = ::std::option::Option<
    unsafe extern "C" fn(
        topic_name_: *const ::std::os::raw::c_char,
        data_: *const SReceiveCallbackDataC,
        par_: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " @brief eCAL timer callback function"]
#[doc = ""]
#[doc = " @param par_         Forwarded user defined parameter."]
pub type TimerCallbackCT =
    ::std::option::Option<unsafe extern "C" fn(par_: *mut ::std::os::raw::c_void)>;
#[doc = " @brief eCAL publisher event callback struct (C variant)."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct SPubEventCallbackDataC {
    #[doc = "!< event type"]
    pub type_: eCAL_Publisher_Event,
    #[doc = "!< event time stamp"]
    pub time: ::std::os::raw::c_longlong,
    #[doc = "!< event clock"]
    pub clock: ::std::os::raw::c_longlong,
}

impl Default for SPubEventCallbackDataC {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " @brief eCAL subscriber event callback struct (C variant)."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct SSubEventCallbackDataC {
    #[doc = "!< event type"]
    pub type_: eCAL_Subscriber_Event,
    #[doc = "!< event time stamp"]
    pub time: ::std::os::raw::c_longlong,
    #[doc = "!< event clock"]
    pub clock: ::std::os::raw::c_longlong,
}

impl Default for SSubEventCallbackDataC {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " @brief eCAL publisher event callback function"]
#[doc = ""]
#[doc = " @param topic_name_  Topic name of the data connection (subscriber)."]
#[doc = " @param data_        Event type struct."]
#[doc = " @param par_         Forwarded user defined parameter."]
pub type SubEventCallbackCT = ::std::option::Option<
    unsafe extern "C" fn(
        topic_name_: *const ::std::os::raw::c_char,
        data_: *const SSubEventCallbackDataC,
        par_: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " @brief eCAL subscriber event callback function"]
#[doc = ""]
#[doc = " @param topic_name_  Topic name of the data connection (publisher)."]
#[doc = " @param data_        Event type struct."]
#[doc = " @param par_         Forwarded user defined parameter."]
pub type PubEventCallbackCT = ::std::option::Option<
    unsafe extern "C" fn(
        topic_name_: *const ::std::os::raw::c_char,
        data_: *const SPubEventCallbackDataC,
        par_: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(i32)]
#[doc = " @brief eCAL QOS history kind mode."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum eQOSPolicy_HistoryKindC {
    #[doc = "< Keep only a number of samples, default value."]
    keep_last_history_qos = 0,
    #[doc = "< Keep all samples until the ResourceLimitsQosPolicy are exhausted."]
    keep_all_history_qos = 1,
}
#[repr(i32)]
#[doc = " @brief eCAL QOS reliability mode."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum eQOSPolicy_ReliabilityC {
    #[doc = "< Best Effort reliability (default for Subscribers)."]
    best_effort_reliability_qos = 0,
    #[doc = "< Reliable reliability (default for Publishers)."]
    reliable_reliability_qos = 1,
}
#[doc = " @brief eCAL data writer QOS settings."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct SWriterQOSC {
    #[doc = "< qos history kind mode"]
    pub history_kind: eQOSPolicy_HistoryKindC,
    #[doc = "< qos history kind mode depth"]
    pub history_kind_depth: ::std::os::raw::c_int,
    #[doc = "< qos reliability mode"]
    pub reliability: eQOSPolicy_ReliabilityC,
}

impl Default for SWriterQOSC {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " @brief eCAL data reader QOS settings."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct SReaderQOSC {
    #[doc = "< qos history kind mode"]
    pub history_kind: eQOSPolicy_HistoryKindC,
    #[doc = "< qos history kind mode depth"]
    pub history_kind_depth: ::std::os::raw::c_int,
    #[doc = "< qos reliability mode"]
    pub reliability: eQOSPolicy_ReliabilityC,
}

impl Default for SReaderQOSC {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(i32)]
#[doc = " @brief eCAL transport layer types."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum eTransportLayerC {
    tlayer_none = 0,
    tlayer_udp_mc = 1,
    tlayer_shm = 4,
    tlayer_inproc = 42,
    tlayer_all = 255,
}
#[repr(i32)]
#[doc = " @brief eCAL transport layer modes."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum eSendModeC {
    smode_none = -1,
    smode_off = 0,
    smode_on = 1,
    smode_auto = 2,
}
extern "C" {
    #[doc = " @brief Instance a publisher."]
    #[doc = ""]
    #[doc = " @return  Handle to new publisher or NULL if failed."]
    pub fn eCAL_Pub_New() -> ECAL_HANDLE;
}
extern "C" {
    #[doc = " @brief Create a publisher."]
    #[doc = ""]
    #[doc = " @param handle_          Publisher handle."]
    #[doc = " @param topic_name_      Unique topic name."]
    #[doc = " @param topic_type_      Topic type name."]
    #[doc = " @param topic_desc_      Topic type description."]
    #[doc = " @param topic_desc_len_  Topic type description length."]
    #[doc = ""]
    #[doc = " @return  None zero if succeeded."]
    pub fn eCAL_Pub_Create(
        handle_: ECAL_HANDLE,
        topic_name_: *const ::std::os::raw::c_char,
        topic_type_: *const ::std::os::raw::c_char,
        topic_desc_: *const ::std::os::raw::c_char,
        topic_desc_len_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Destroy a publisher."]
    #[doc = ""]
    #[doc = " @param handle_  Publisher handle."]
    #[doc = ""]
    #[doc = " @return  None zero if succeeded."]
    pub fn eCAL_Pub_Destroy(handle_: ECAL_HANDLE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Setup topic type description."]
    #[doc = ""]
    #[doc = " @param handle_          Publisher handle."]
    #[doc = " @param topic_desc_      Topic type description."]
    #[doc = " @param topic_desc_len_  Topic type description length."]
    #[doc = ""]
    #[doc = " @return  None zero if succeeded."]
    pub fn eCAL_Pub_SetDescription(
        handle_: ECAL_HANDLE,
        topic_desc_: *const ::std::os::raw::c_char,
        topic_desc_len_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Share topic type."]
    #[doc = ""]
    #[doc = " @param handle_ Publisher handle."]
    #[doc = " @param state_  Set type share mode (none zero == share type)."]
    #[doc = ""]
    #[doc = " @return  None zero if succeeded."]
    pub fn eCAL_Pub_ShareType(
        handle_: ECAL_HANDLE,
        state_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Share topic description."]
    #[doc = ""]
    #[doc = " @param handle_ Publisher handle."]
    #[doc = " @param state_  Set description share mode (none zero == share description)."]
    #[doc = ""]
    #[doc = " @return  None zero if succeeded."]
    pub fn eCAL_Pub_ShareDescription(
        handle_: ECAL_HANDLE,
        state_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set publisher quality of service attributes."]
    #[doc = ""]
    #[doc = " @param handle_  Publisher handle."]
    #[doc = " @param qos_     Quality of service policies."]
    #[doc = ""]
    #[doc = " @return  None zero if succeeded."]
    pub fn eCAL_Pub_SetQOS(handle_: ECAL_HANDLE, qos_: SWriterQOSC) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get publisher quality of service attributes."]
    #[doc = ""]
    #[doc = " @param handle_  Publisher handle."]
    #[doc = " @param qos_     Quality of service policies."]
    #[doc = ""]
    #[doc = " @return  None zero if succeeded."]
    pub fn eCAL_Pub_GetQOS(handle_: ECAL_HANDLE, qos_: *mut SWriterQOSC) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set publisher send mode for specific transport layer."]
    #[doc = ""]
    #[doc = " @param handle_  Publisher handle."]
    #[doc = " @param layer_   Transport layer."]
    #[doc = " @param mode_    Send mode."]
    #[doc = ""]
    #[doc = " @return  True if it succeeds, false if it fails."]
    pub fn eCAL_Pub_SetLayerMode(
        handle_: ECAL_HANDLE,
        layer_: eTransportLayerC,
        mode_: eSendModeC,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set publisher maximum transmit bandwidth for the udp layer."]
    #[doc = ""]
    #[doc = " @param handle_     Publisher handle."]
    #[doc = " @param bandwidth_  Maximum bandwidth in bytes/s (-1 == unlimited)."]
    #[doc = ""]
    #[doc = " @return  True if it succeeds, false if it fails."]
    pub fn eCAL_Pub_SetMaxBandwidthUDP(
        handle_: ECAL_HANDLE,
        bandwidth_: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set publisher maximum transmit bandwidth for the udp layer."]
    #[doc = ""]
    #[doc = " @param handle_  Publisher handle."]
    #[doc = " @param id_      The topic id for subscriber side filtering (0 == no id)."]
    #[doc = ""]
    #[doc = " @return  True if it succeeds, false if it fails."]
    pub fn eCAL_Pub_SetID(
        handle_: ECAL_HANDLE,
        id_: ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set publisher maximum number of used shared memory buffers."]
    #[doc = ""]
    #[doc = " @param handle_     Publisher handle."]
    #[doc = " @param buffering_  Maximum number of used buffers (needs to be greater than 1, default = 1)."]
    #[doc = ""]
    #[doc = " @return  True if it succeeds, false if it fails."]
    pub fn eCAL_Pub_ShmSetBufferCount(
        handle_: ECAL_HANDLE,
        buffering_: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Query if the publisher is subscribed."]
    #[doc = ""]
    #[doc = " @param handle_  Publisher handle."]
    #[doc = ""]
    #[doc = " @return  None zero if subscribed."]
    pub fn eCAL_Pub_IsSubscribed(handle_: ECAL_HANDLE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Send a message to all subscribers."]
    #[doc = ""]
    #[doc = " @param handle_   Publisher handle."]
    #[doc = " @param buf_      Buffer that contains content to send."]
    #[doc = " @param buf_len_  Send buffer length."]
    #[doc = " @param time_     Send time (-1 = use eCAL system time in us, default = -1)."]
    #[doc = ""]
    #[doc = " @return  Number of bytes sent."]
    pub fn eCAL_Pub_Send(
        handle_: ECAL_HANDLE,
        buf_: *const ::std::os::raw::c_void,
        buf_len_: ::std::os::raw::c_int,
        time_: ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Add callback function for publisher events."]
    #[doc = ""]
    #[doc = " @param handle_    Publisher handle."]
    #[doc = " @param type_      The event type to react on."]
    #[doc = " @param callback_  The callback function to add."]
    #[doc = " @param par_       User defined context that will be forwarded to the callback function."]
    #[doc = ""]
    #[doc = " @return  None zero if succeeded."]
    pub fn eCAL_Pub_AddEventCallbackC(
        handle_: ECAL_HANDLE,
        type_: eCAL_Publisher_Event,
        callback_: PubEventCallbackCT,
        par_: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Remove callback function for publisher events."]
    #[doc = ""]
    #[doc = " @param handle_  Publisher handle."]
    #[doc = " @param type_    The event type to remove."]
    #[doc = ""]
    #[doc = " @return  None zero if succeeded."]
    pub fn eCAL_Pub_RemEventCallback(
        handle_: ECAL_HANDLE,
        type_: eCAL_Publisher_Event,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Dump the whole class state into a string buffer."]
    #[doc = ""]
    #[doc = " @param handle_         Publisher handle."]
    #[doc = " @param [out] buf_      Pointer to store the monitoring information."]
    #[doc = " @param       buf_len_  Length of allocated buffer or ECAL_ALLOCATE_4ME if"]
    #[doc = "                        eCAL should allocate the buffer for you (see eCAL_FreeMem)."]
    #[doc = ""]
    #[doc = " @return  Dump buffer length or zero if failed."]
    pub fn eCAL_Pub_Dump(
        handle_: ECAL_HANDLE,
        buf_: *mut ::std::os::raw::c_void,
        buf_len_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(i32)]
#[doc = " @brief  Service call state."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum eCallState {
    #[doc = "!< undefined"]
    call_state_none = 0,
    #[doc = "!< executed (successfully)"]
    call_state_executed = 1,
    #[doc = "!< failed"]
    call_state_failed = 2,
}
#[doc = " @brief eCAL service info struct returned as service response (C API)."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct SServiceInfoC {
    #[doc = "!< host name"]
    pub host_name: *const ::std::os::raw::c_char,
    #[doc = "!< service name"]
    pub service_name: *const ::std::os::raw::c_char,
    #[doc = "!< service id"]
    pub service_id: *const ::std::os::raw::c_char,
    #[doc = "!< method name"]
    pub method_name: *const ::std::os::raw::c_char,
    #[doc = "!< error message in case of failure"]
    pub error_msg: *const ::std::os::raw::c_char,
    #[doc = "!< return state from method callback"]
    pub ret_state: ::std::os::raw::c_int,
    #[doc = "!< service call state"]
    pub call_state: eCallState,
    #[doc = "!< response from service call"]
    pub response: *const ::std::os::raw::c_char,
    #[doc = "!< response length"]
    pub response_len: ::std::os::raw::c_int
}

impl Default for SServiceInfoC {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " @brief eCAL service method callback function (server side)"]
#[doc = ""]
#[doc = " @param method_             Method name."]
#[doc = " @param req_type_           Type of the request message."]
#[doc = " @param resp_type_          Type of the response message."]
#[doc = " @param request_            Request payload."]
#[doc = " @param request_len_        Request payload length."]
#[doc = " @param [out] reponse_      Method response payload."]
#[doc = " @param [out] reponse_len_  Method response payload length."]
#[doc = " @param par_                Forwarded user defined parameter."]
pub type MethodCallbackCT = ::std::option::Option<
    unsafe extern "C" fn(
        method_: *const ::std::os::raw::c_char,
        req_type_: *const ::std::os::raw::c_char,
        resp_type_: *const ::std::os::raw::c_char,
        request_: *const ::std::os::raw::c_char,
        request_len_: ::std::os::raw::c_int,
        response_: *mut *mut ::std::os::raw::c_void,
        response_len_: *mut ::std::os::raw::c_int,
        par_: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @brief eCAL service response callback function (client side)"]
#[doc = ""]
#[doc = " @param service_info_       Service info struct."]
#[doc = " @param reponse_            Method response payload."]
#[doc = " @param reponse_len_        Method response payload length."]
#[doc = " @param par_                Forwarded user defined parameter."]
pub type ResponseCallbackCT = ::std::option::Option<
    unsafe extern "C" fn(
        service_info_: *const SServiceInfoC,
        response_: *const ::std::os::raw::c_char,
        response_len_: ::std::os::raw::c_int,
        par_: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " @brief Create a server."]
    #[doc = ""]
    #[doc = " @param service_name_  Service name."]
    #[doc = ""]
    #[doc = " @return  Handle to created server or NULL if failed."]
    pub fn eCAL_Server_Create(service_name_: *const ::std::os::raw::c_char) -> ECAL_HANDLE;
}
extern "C" {
    #[doc = " @brief Destroy a server."]
    #[doc = ""]
    #[doc = " @param handle_  Server handle."]
    #[doc = ""]
    #[doc = " @return  None zero if succeeded."]
    pub fn eCAL_Server_Destroy(handle_: ECAL_HANDLE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Add server method callback."]
    #[doc = ""]
    #[doc = " @param handle_     Server handle."]
    #[doc = " @param method_     Service method name."]
    #[doc = " @param req_type_   Method request type (default = \"\")."]
    #[doc = " @param resp_type_  Method response type (default = \"\")."]
    #[doc = " @param callback_   Callback function for server request."]
    #[doc = " @param par_        User defined context that will be forwarded to the request function."]
    #[doc = ""]
    #[doc = " @return  None zero if succeeded."]
    pub fn eCAL_Server_AddMethodCallbackC(
        handle_: ECAL_HANDLE,
        method_: *const ::std::os::raw::c_char,
        req_type_: *const ::std::os::raw::c_char,
        resp_type_: *const ::std::os::raw::c_char,
        callback_: MethodCallbackCT,
        par_: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Remove server method callback."]
    #[doc = ""]
    #[doc = " @param handle_  Server handle."]
    #[doc = " @param method_  Service method name."]
    #[doc = ""]
    #[doc = " @return  None zero if succeeded."]
    pub fn eCAL_Server_RemMethodCallbackC(
        handle_: ECAL_HANDLE,
        method_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Retrieve the service name."]
    #[doc = ""]
    #[doc = " @param       handle_   Server handle."]
    #[doc = " @param [out] buf_      Pointer to store the server service string."]
    #[doc = " @param       buf_len_  Length of allocated buffer or ECAL_ALLOCATE_4ME if"]
    #[doc = "                        eCAL should allocate the buffer for you (see eCAL_FreeMem)."]
    #[doc = ""]
    #[doc = " @return  Description buffer length or zero if failed."]
    pub fn eCAL_Server_GetServiceName(
        handle_: ECAL_HANDLE,
        buf_: *mut ::std::os::raw::c_void,
        buf_len_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Create a client."]
    #[doc = ""]
    #[doc = " @param service_name_  Service name."]
    #[doc = ""]
    #[doc = " @return  Handle to created client or NULL if failed."]
    pub fn eCAL_Client_Create(service_name_: *const ::std::os::raw::c_char) -> ECAL_HANDLE;
}
extern "C" {
    #[doc = " @brief Destroy a client."]
    #[doc = ""]
    #[doc = " @param handle_  Client handle."]
    #[doc = ""]
    #[doc = " @return  None zero if succeeded."]
    pub fn eCAL_Client_Destroy(handle_: ECAL_HANDLE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Change the host name filter for that client instance"]
    #[doc = ""]
    #[doc = " @param handle_     Client handle."]
    #[doc = " @param host_name_  Host name filter (empty or \"*\" == all hosts)"]
    #[doc = ""]
    #[doc = " @return  None zero if succeeded."]
    pub fn eCAL_Client_SetHostName(
        handle_: ECAL_HANDLE,
        host_name_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Call method of this service (none blocking variant with callback)."]
    #[doc = ""]
    #[doc = " @param handle_       Client handle."]
    #[doc = " @param method_name_  Method name."]
    #[doc = " @param request_      Request message buffer."]
    #[doc = " @param request_len_  Request message length."]
    #[doc = " @param timeout       Request timeout in milliseconds."]
    #[doc = ""]
    #[doc = " @return  None zero if succeeded."]
    pub fn eCAL_Client_Call(
        handle_: ECAL_HANDLE,
        method_name_: *const ::std::os::raw::c_char,
        request_: *const ::std::os::raw::c_char,
        request_len_: ::std::os::raw::c_int,
        time_out_: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Call method of this service (blocking variant with timeout)."]
    #[doc = ""]
    #[doc = " @param       handle_        Client handle."]
    #[doc = " @param       method_name_   Method name."]
    #[doc = " @param       request_       Request message buffer."]
    #[doc = " @param       request_len_   Request message length."]
    #[doc = " @param       timeout_       timeout in milliseconds."]
    #[doc = " @param [out] service_info_  Service info struct with additional infos like call state and"]
    #[doc = "                             error message."]
    #[doc = " @param [out] response_      Pointer to the allocated buffer for the response message."]
    #[doc = " @param       response_len_  Response message buffer length or ECAL_ALLOCATE_4ME if"]
    #[doc = "                             eCAL should allocate the buffer for you (see eCAL_FreeMem)."]
    #[doc = ""]
    #[doc = " @return  Size of response buffer if succeeded, otherwise zero."]
    pub fn eCAL_Client_Call_Wait(
        handle_: ECAL_HANDLE,
        method_name_: *const ::std::os::raw::c_char,
        request_: *const ::std::os::raw::c_char,
        request_len_: ::std::os::raw::c_int,
        time_out_: ::std::os::raw::c_long,
        service_info_: *mut SServiceInfoC,
        response_: *mut ::std::os::raw::c_void,
        response_len_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Add server response callback."]
    #[doc = ""]
    #[doc = " @param handle_    Client handle."]
    #[doc = " @param callback_  Callback function for server response."]
    #[doc = " @param par_       User defined context that will be forwarded to the callback function."]
    #[doc = ""]
    #[doc = " @return  None zero if succeeded."]
    pub fn eCAL_Client_AddResponseCallbackC(
        handle_: ECAL_HANDLE,
        callback_: ResponseCallbackCT,
        par_: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Remove server response callback."]
    #[doc = ""]
    #[doc = " @param handle_  Client handle."]
    #[doc = ""]
    #[doc = " @return  None zero if succeeded."]
    pub fn eCAL_Client_RemResponseCallback(handle_: ECAL_HANDLE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Instance a subscriber."]
    #[doc = ""]
    #[doc = " @return  Handle to new subscriber or NULL if failed."]
    pub fn eCAL_Sub_New() -> ECAL_HANDLE;
}
extern "C" {
    #[doc = " @brief Create a subscriber."]
    #[doc = ""]
    #[doc = " @param handle_          Subscriber handle."]
    #[doc = " @param topic_name_      Unique topic name."]
    #[doc = " @param topic_type_      Topic type name."]
    #[doc = " @param topic_desc_      Topic description."]
    #[doc = " @param topic_desc_len_  Topic type description length."]
    #[doc = ""]
    #[doc = " @return  None zero if succeeded."]
    pub fn eCAL_Sub_Create(
        handle_: ECAL_HANDLE,
        topic_name_: *const ::std::os::raw::c_char,
        topic_type_: *const ::std::os::raw::c_char,
        topic_desc_: *const ::std::os::raw::c_char,
        topic_desc_len_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Destroy a subscriber."]
    #[doc = ""]
    #[doc = " @param handle_  Subscriber handle."]
    #[doc = ""]
    #[doc = " @return  None zero if succeeded."]
    pub fn eCAL_Sub_Destroy(handle_: ECAL_HANDLE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set subscriber quality of service attributes."]
    #[doc = ""]
    #[doc = " @param handle_  Subscriber handle."]
    #[doc = " @param qos_     Quality of service policies."]
    #[doc = ""]
    #[doc = " @return  None zero if succeeded."]
    pub fn eCAL_Sub_SetQOS(handle_: ECAL_HANDLE, qos_: SReaderQOSC) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get subscriber quality of service attributes."]
    #[doc = ""]
    #[doc = " @param handle_  Subscriber handle."]
    #[doc = " @param qos_     Quality of service policies."]
    #[doc = ""]
    #[doc = " @return  None zero if succeeded."]
    pub fn eCAL_Sub_GetQOS(handle_: ECAL_HANDLE, qos_: *mut SReaderQOSC) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set a set of id's to prefiltering topics (see eCAL_Pub_SetID)."]
    #[doc = ""]
    #[doc = " @param handle_    Subscriber handle."]
    #[doc = " @param id_array_  Array of id's (Use nullptr to reset id's)."]
    #[doc = " @param id_num_    Number of id's."]
    #[doc = ""]
    #[doc = " @return  None zero if succeeded."]
    pub fn eCAL_Sub_SetID(
        handle_: ECAL_HANDLE,
        id_array_: *const ::std::os::raw::c_longlong,
        id_num_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Receive a message from the publisher."]
    #[doc = ""]
    #[doc = " @param       handle_       Subscriber handle."]
    #[doc = " @param [out] buf_          Buffer to store the received message content."]
    #[doc = " @param       buf_len_      Length of the receive buffer or ECAL_ALLOCATE_4ME if"]
    #[doc = "                            eCAL should allocate the buffer for you (see eCAL_FreeMem)."]
    #[doc = " @param [out] time_         Time from publisher in us."]
    #[doc = " @param       rcv_timeout_  Maximum time before receive operation returns (in milliseconds, -1 means infinite)."]
    #[doc = ""]
    #[doc = " @return  Length of received buffer."]
    pub fn eCAL_Sub_Receive(
        handle_: ECAL_HANDLE,
        buf_: *mut *mut ::std::os::raw::c_void,
        buf_len_: ::std::os::raw::c_int,
        time_: *mut ::std::os::raw::c_longlong,
        rcv_timeout_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Add callback function for incoming receives."]
    #[doc = ""]
    #[doc = " @param handle_    Subscriber handle."]
    #[doc = " @param callback_  The callback function to add."]
    #[doc = " @param par_       User defined context that will be forwarded to the callback function."]
    #[doc = ""]
    #[doc = " @return  None zero if succeeded."]
    pub fn eCAL_Sub_AddReceiveCallbackC(
        handle_: ECAL_HANDLE,
        callback_: ReceiveCallbackCT,
        par_: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Remove callback function for incoming receives."]
    #[doc = ""]
    #[doc = " @param  handle_  Subscriber handle."]
    #[doc = ""]
    #[doc = " @return  None zero if succeeded."]
    pub fn eCAL_Sub_RemReceiveCallback(handle_: ECAL_HANDLE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Add callback function for subscriber events."]
    #[doc = ""]
    #[doc = " @param handle_    Subscriber handle."]
    #[doc = " @param type_      The event type to react on."]
    #[doc = " @param callback_  The callback function to add."]
    #[doc = " @param par_       User defined context that will be forwarded to the callback function."]
    #[doc = ""]
    #[doc = " @return  None zero if succeeded."]
    pub fn eCAL_Sub_AddEventCallbackC(
        handle_: ECAL_HANDLE,
        type_: eCAL_Subscriber_Event,
        callback_: SubEventCallbackCT,
        par_: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Remove callback function for subscriber events."]
    #[doc = ""]
    #[doc = " @param handle_  Subscriber handle."]
    #[doc = " @param type_    The event type to remove."]
    #[doc = ""]
    #[doc = " @return  None zero if succeeded."]
    pub fn eCAL_Sub_RemEventCallback(
        handle_: ECAL_HANDLE,
        type_: eCAL_Subscriber_Event,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Gets description of the connected topic."]
    #[doc = ""]
    #[doc = " @param       handle_   Subscriber handle."]
    #[doc = " @param [out] buf_      Pointer to store the subscriber description string."]
    #[doc = " @param       buf_len_  Length of allocated buffer or ECAL_ALLOCATE_4ME if"]
    #[doc = "                        eCAL should allocate the buffer for you (see eCAL_FreeMem)."]
    #[doc = ""]
    #[doc = " @return  Description buffer length or zero if failed."]
    pub fn eCAL_Sub_GetDescription(
        handle_: ECAL_HANDLE,
        buf_: *mut ::std::os::raw::c_void,
        buf_len_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set the timeout parameter for triggering"]
    #[doc = "          the timeout callback."]
    #[doc = ""]
    #[doc = " @param handle_   Subscriber handle."]
    #[doc = " @param timeout_  The timeout in milliseconds."]
    #[doc = ""]
    #[doc = " @return  True if succeeded, false if not."]
    pub fn eCAL_Sub_SetTimeout(
        handle_: ECAL_HANDLE,
        timeout_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Dump the whole class state into a string buffer."]
    #[doc = ""]
    #[doc = " @param handle_         Publisher handle."]
    #[doc = " @param [out] buf_      Pointer to store the monitoring information."]
    #[doc = " @param       buf_len_  Length of allocated buffer or ECAL_ALLOCATE_4ME if"]
    #[doc = "                        eCAL should allocate the buffer for you (see eCAL_FreeMem)."]
    #[doc = ""]
    #[doc = " @return  Dump buffer length or zero if failed."]
    pub fn eCAL_Sub_Dump(
        handle_: ECAL_HANDLE,
        buf_: *mut ::std::os::raw::c_void,
        buf_len_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Create a subscriber."]
    #[doc = ""]
    #[doc = " @param topic_name_  Unique topic name."]
    #[doc = ""]
    #[doc = " @return  Handle to created subscriber or NULL if failed."]
    pub fn eCAL_Proto_Dyn_JSON_Sub_Create(
        topic_name_: *const ::std::os::raw::c_char,
    ) -> ECAL_HANDLE;
}
extern "C" {
    #[doc = " @brief Destroy a subscriber."]
    #[doc = ""]
    #[doc = " @param handle_  Subscriber handle."]
    #[doc = ""]
    #[doc = " @return  None zero if succeeded."]
    pub fn eCAL_Proto_Dyn_JSON_Sub_Destroy(handle_: ECAL_HANDLE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Add callback function for incoming receives."]
    #[doc = ""]
    #[doc = " @param handle_    Subscriber handle."]
    #[doc = " @param callback_  The callback function to add."]
    #[doc = " @param par_       User defined context that will be forwarded to the callback function."]
    #[doc = ""]
    #[doc = " @return  None zero if succeeded."]
    pub fn eCAL_Proto_Dyn_JSON_Sub_AddReceiveCallbackC(
        handle_: ECAL_HANDLE,
        callback_: ReceiveCallbackCT,
        par_: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Remove callback function for incoming receives."]
    #[doc = ""]
    #[doc = " @param  handle_  Subscriber handle."]
    #[doc = ""]
    #[doc = " @return  None zero if succeeded."]
    pub fn eCAL_Proto_Dyn_JSON_Sub_RemReceiveCallback(
        handle_: ECAL_HANDLE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief  Get interface name."]
    #[doc = ""]
    #[doc = " @return  Get time sync interface name."]
    pub fn eCAL_Time_GetName(
        name_: *mut ::std::os::raw::c_void,
        name_len_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief  Get current time"]
    #[doc = ""]
    #[doc = " @return  current time in us."]
    pub fn eCAL_Time_GetMicroSeconds() -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " @brief  Get current time"]
    #[doc = ""]
    #[doc = " @return  current time in ns."]
    pub fn eCAL_Time_GetNanoSeconds() -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " @brief  Set current time in nano seconds if host is time master."]
    #[doc = ""]
    #[doc = " @param time_  Current time in ns."]
    #[doc = ""]
    #[doc = " @return  Zero if succeeded non zero otherwise."]
    pub fn eCAL_Time_SetNanoSeconds(time_: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief  Returns time synchronization state."]
    #[doc = ""]
    #[doc = " @return  Non zero if process is time synchronized."]
    pub fn eCAL_Time_IsTimeSynchronized() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief  Checks whether this host is time master."]
    #[doc = ""]
    #[doc = " @return  Non zero if host is time master."]
    pub fn eCAL_Time_IsTimeMaster() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Blocks for the given amount of nanoseconds."]
    #[doc = ""]
    #[doc = " The actual amount of (real-) time is influenced by the current rate at"]
    #[doc = " which the time is proceeding."]
    #[doc = " It is not guaranteed, that the precision of this function actually  is in"]
    #[doc = " nanoseconds. Limitations of the operating system might reduce the accuracy."]
    #[doc = ""]
    #[doc = " @param duration_nsecs_ the duration in nanoseconds"]
    pub fn eCAL_Time_SleepForNanoseconds(duration_nsecs_: ::std::os::raw::c_longlong);
}
extern "C" {
    #[doc = " @brief Get the current error code and status message"]
    #[doc = ""]
    #[doc = " An error code of 0 is considered to be OK. Any other error code is"]
    #[doc = " considered to indicate a problem. Time Adapters may use a set of error"]
    #[doc = " codes to indicate specific problems."]
    #[doc = " The status message may be a nullpointer. If the user is not interested in"]
    #[doc = " the status message, max_len_ has to be < 0."]
    #[doc = " If max_len_ is ECAL_ALLOCATE_4ME, memory will be allocated. The calling"]
    #[doc = " function has to free it."]
    #[doc = ""]
    #[doc = " @param error_ [out] The error code"]
    #[doc = " @param status_message_ [out] A pointer to a char array for the status message. The message will NOT be null-terminated."]
    #[doc = " @param max_len_ [in] The length of the allocated memory for the status_message_, ECAL_ALOCATE_4ME if the function has to allocate memory or -1 if not interested in the message."]
    #[doc = " @return"]
    pub fn eCAL_Time_GetStatus(
        error_: *mut ::std::os::raw::c_int,
        status_message_: *mut *mut ::std::os::raw::c_char,
        max_len_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Create a timer."]
    #[doc = ""]
    #[doc = " @return  Handle to created timer or NULL if failed."]
    pub fn eCAL_Timer_Create() -> ECAL_HANDLE;
}
extern "C" {
    #[doc = " @brief Create a timer."]
    #[doc = ""]
    #[doc = " @param handle_  Timer handle."]
    #[doc = ""]
    #[doc = " @return  Handle to created timer or NULL if failed."]
    pub fn eCAL_Timer_Destroy(handle_: ECAL_HANDLE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Start the timer."]
    #[doc = ""]
    #[doc = " @param handle_    Timer handle."]
    #[doc = " @param timeout_   Timer callback loop time in ms."]
    #[doc = " @param callback_  The callback function."]
    #[doc = " @param delay_     Timer callback delay for first call in ms."]
    #[doc = " @param par_       User defined context that will be forwarded to the callback function."]
    #[doc = ""]
    #[doc = " @return  None zero if succeeded."]
    pub fn eCAL_Timer_Start(
        handle_: ECAL_HANDLE,
        timeout_: ::std::os::raw::c_int,
        callback_: TimerCallbackCT,
        delay_: ::std::os::raw::c_int,
        par_: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Stop the timer."]
    #[doc = ""]
    #[doc = " @param handle_  Timer handle."]
    #[doc = ""]
    #[doc = " @return  None zero if succeeded."]
    pub fn eCAL_Timer_Stop(handle_: ECAL_HANDLE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Send shutdown event to specified local user process using it's unit name."]
    #[doc = ""]
    #[doc = " @param unit_name_  Process unit name."]
    pub fn eCAL_Util_ShutdownUnitName(unit_name_: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " @brief Send shutdown event to specified local user process using it's process id."]
    #[doc = ""]
    #[doc = " @param process_id_  Process id."]
    pub fn eCAL_Util_ShutdownProcessID(process_id_: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " @brief Send shutdown event to all local user processes."]
    pub fn eCAL_Util_ShutdownProcesses();
}
extern "C" {
    #[doc = " @brief Send shutdown event to all local core components."]
    pub fn eCAL_Util_ShutdownCore();
}
extern "C" {
    #[doc = " @brief Enable eCAL message loop back,"]
    #[doc = "          that means subscriber will receive messages from"]
    #[doc = "          publishers of the same process (default == false)."]
    #[doc = ""]
    #[doc = " @param state_  Switch on message loop back.."]
    pub fn eCAL_Util_EnableLoopback(state_: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " @brief Gets type name of the specified topic."]
    #[doc = ""]
    #[doc = " @param       topic_name_      Topic name."]
    #[doc = " @param [out] topic_type_      Pointer to store the type name information."]
    #[doc = " @param       topic_type_len_  Length of allocated buffer or ECAL_ALLOCATE_4ME if"]
    #[doc = "                               eCAL should allocate the buffer for you (see eCAL_FreeMem)."]
    #[doc = ""]
    #[doc = " @return  Type name buffer length or zero if failed."]
    pub fn eCAL_Util_GetTypeName(
        topic_name_: *const ::std::os::raw::c_char,
        topic_type_: *mut ::std::os::raw::c_void,
        topic_type_len_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Gets type description of the specified topic."]
    #[doc = ""]
    #[doc = " @param       topic_name_      Topic name."]
    #[doc = " @param [out] topic_desc_      Pointer to store the type description information."]
    #[doc = " @param       topic_desc_len_  Length of allocated buffer or ECAL_ALLOCATE_4ME if"]
    #[doc = "                               eCAL should allocate the buffer for you (see eCAL_FreeMem)."]
    #[doc = ""]
    #[doc = " @return  Type description buffer length or zero if failed."]
    pub fn eCAL_Util_GetDescription(
        topic_name_: *const ::std::os::raw::c_char,
        topic_desc_: *mut ::std::os::raw::c_void,
        topic_desc_len_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}


#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn bindgen_test_layout_SReceiveCallbackDataC() {
        assert_eq!(
            ::std::mem::size_of::<SReceiveCallbackDataC>(),
            40usize,
            concat!("Size of: ", stringify!(SReceiveCallbackDataC))
        );
        assert_eq!(
            ::std::mem::align_of::<SReceiveCallbackDataC>(),
            8usize,
            concat!("Alignment of ", stringify!(SReceiveCallbackDataC))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<SReceiveCallbackDataC>())).buf as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SReceiveCallbackDataC),
                "::",
                stringify!(buf)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<SReceiveCallbackDataC>())).size as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SReceiveCallbackDataC),
                "::",
                stringify!(size)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<SReceiveCallbackDataC>())).id as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SReceiveCallbackDataC),
                "::",
                stringify!(id)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<SReceiveCallbackDataC>())).time as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(SReceiveCallbackDataC),
                "::",
                stringify!(time)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<SReceiveCallbackDataC>())).clock as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(SReceiveCallbackDataC),
                "::",
                stringify!(clock)
            )
        );
    }

    #[test]
    fn bindgen_test_layout_SServiceInfoC() {
        assert_eq!(
            ::std::mem::size_of::<SServiceInfoC>(),
            40usize,
            concat!("Size of: ", stringify!(SServiceInfoC))
        );
        assert_eq!(
            ::std::mem::align_of::<SServiceInfoC>(),
            8usize,
            concat!("Alignment of ", stringify!(SServiceInfoC))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<SServiceInfoC>())).host_name as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SServiceInfoC),
                "::",
                stringify!(host_name)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<SServiceInfoC>())).service_name as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SServiceInfoC),
                "::",
                stringify!(service_name)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<SServiceInfoC>())).method_name as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SServiceInfoC),
                "::",
                stringify!(method_name)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<SServiceInfoC>())).error_msg as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(SServiceInfoC),
                "::",
                stringify!(error_msg)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<SServiceInfoC>())).ret_state as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(SServiceInfoC),
                "::",
                stringify!(ret_state)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<SServiceInfoC>())).call_state as *const _ as usize },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(SServiceInfoC),
                "::",
                stringify!(call_state)
            )
        );
    }

    #[test]
    fn bindgen_test_layout_SReaderQOSC() {
        assert_eq!(
            ::std::mem::size_of::<SReaderQOSC>(),
            12usize,
            concat!("Size of: ", stringify!(SReaderQOSC))
        );
        assert_eq!(
            ::std::mem::align_of::<SReaderQOSC>(),
            4usize,
            concat!("Alignment of ", stringify!(SReaderQOSC))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<SReaderQOSC>())).history_kind as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SReaderQOSC),
                "::",
                stringify!(history_kind)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<SReaderQOSC>())).history_kind_depth as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SReaderQOSC),
                "::",
                stringify!(history_kind_depth)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<SReaderQOSC>())).reliability as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SReaderQOSC),
                "::",
                stringify!(reliability)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_SWriterQOSC() {
        assert_eq!(
            ::std::mem::size_of::<SWriterQOSC>(),
            12usize,
            concat!("Size of: ", stringify!(SWriterQOSC))
        );
        assert_eq!(
            ::std::mem::align_of::<SWriterQOSC>(),
            4usize,
            concat!("Alignment of ", stringify!(SWriterQOSC))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<SWriterQOSC>())).history_kind as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SWriterQOSC),
                "::",
                stringify!(history_kind)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<SWriterQOSC>())).history_kind_depth as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SWriterQOSC),
                "::",
                stringify!(history_kind_depth)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<SWriterQOSC>())).reliability as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SWriterQOSC),
                "::",
                stringify!(reliability)
            )
        );
    }

    #[test]
    fn bindgen_test_layout_SSubEventCallbackDataC() {
        assert_eq!(
            ::std::mem::size_of::<SSubEventCallbackDataC>(),
            24usize,
            concat!("Size of: ", stringify!(SSubEventCallbackDataC))
        );
        assert_eq!(
            ::std::mem::align_of::<SSubEventCallbackDataC>(),
            8usize,
            concat!("Alignment of ", stringify!(SSubEventCallbackDataC))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<SSubEventCallbackDataC>())).type_ as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SSubEventCallbackDataC),
                "::",
                stringify!(type_)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<SSubEventCallbackDataC>())).time as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SSubEventCallbackDataC),
                "::",
                stringify!(time)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<SSubEventCallbackDataC>())).clock as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SSubEventCallbackDataC),
                "::",
                stringify!(clock)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_SPubEventCallbackDataC() {
        assert_eq!(
            ::std::mem::size_of::<SPubEventCallbackDataC>(),
            24usize,
            concat!("Size of: ", stringify!(SPubEventCallbackDataC))
        );
        assert_eq!(
            ::std::mem::align_of::<SPubEventCallbackDataC>(),
            8usize,
            concat!("Alignment of ", stringify!(SPubEventCallbackDataC))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<SPubEventCallbackDataC>())).type_ as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SPubEventCallbackDataC),
                "::",
                stringify!(type_)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<SPubEventCallbackDataC>())).time as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SPubEventCallbackDataC),
                "::",
                stringify!(time)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<SPubEventCallbackDataC>())).clock as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SPubEventCallbackDataC),
                "::",
                stringify!(clock)
            )
        );
    }
}
